module linux.errno_;
import plat_version;

import internal.linux.errno_;
import string;
import errno_;

extern (C):
__gshared:

char *strerror(int num) {
	// can't return "whatever" because d memory is weird
	__gshared static char[128] ret;

	switch (cast(Errno)num) {
		case Errno.EPERM: strcpy(ret.ptr, "Operation not permitted."); break;
		case Errno.ENOENT: strcpy(ret.ptr, "No such file or directory."); break;
		case Errno.ESRCH: strcpy(ret.ptr, "No such process."); break;
		case Errno.EINTR: strcpy(ret.ptr, "Interrupted system call."); break;
		case Errno.EIO: strcpy(ret.ptr, "I/O error."); break;
		case Errno.ENXIO: strcpy(ret.ptr, "No such device or address."); break;
		case Errno.E2BIG: strcpy(ret.ptr, "Argument list too long."); break;
		case Errno.ENOEXEC: strcpy(ret.ptr, "Exec format error."); break;
		case Errno.EBADF: strcpy(ret.ptr, "Bad file number."); break;
		case Errno.ECHILD: strcpy(ret.ptr, "No child processes."); break;
		case Errno.EAGAIN: strcpy(ret.ptr, "Try again."); break;
		case Errno.ENOMEM: strcpy(ret.ptr, "Out of memory."); break;
		case Errno.EACCES: strcpy(ret.ptr, "Permission denied."); break;
		case Errno.EFAULT: strcpy(ret.ptr, "Bad address."); break;
		case Errno.ENOTBLK: strcpy(ret.ptr, "Block device required."); break;
		case Errno.EBUSY: strcpy(ret.ptr, "Device or resource busy."); break;
		case Errno.EEXIST: strcpy(ret.ptr, "File exists."); break;
		case Errno.EXDEV: strcpy(ret.ptr, "Cross-device link."); break;
		case Errno.ENODEV: strcpy(ret.ptr, "No such device."); break;
		case Errno.ENOTDIR: strcpy(ret.ptr, "Not a directory."); break;
		case Errno.EISDIR: strcpy(ret.ptr, "Is a directory."); break;
		case Errno.EINVAL: strcpy(ret.ptr, "Invalid argument."); break;
		case Errno.ENFILE: strcpy(ret.ptr, "File table overflow."); break;
		case Errno.EMFILE: strcpy(ret.ptr, "Too many open files."); break;
		case Errno.ENOTTY: strcpy(ret.ptr, "Not a typewriter."); break;
		case Errno.ETXTBSY: strcpy(ret.ptr, "Text file busy."); break;
		case Errno.EFBIG: strcpy(ret.ptr, "File too large."); break;
		case Errno.ENOSPC: strcpy(ret.ptr, "No space left on device."); break;
		case Errno.ESPIPE: strcpy(ret.ptr, "Illegal seek."); break;
		case Errno.EROFS: strcpy(ret.ptr, "Read-only file system."); break;
		case Errno.EMLINK: strcpy(ret.ptr, "Too many links."); break;
		case Errno.EPIPE: strcpy(ret.ptr, "Broken pipe."); break;
		case Errno.EDOM: strcpy(ret.ptr, "Math argument out of domain of func."); break;
		case Errno.ERANGE: strcpy(ret.ptr, "Math result not representable."); break;
		case Errno.EDEADLK: strcpy(ret.ptr, "Resource deadlock would occur."); break;
		case Errno.ENAMETOOLONG: strcpy(ret.ptr, "File name too long."); break;
		case Errno.ENOLCK: strcpy(ret.ptr, "No record locks available."); break;
		case Errno.ENOSYS: strcpy(ret.ptr, "Invalid system call number."); break;
		case Errno.ENOTEMPTY: strcpy(ret.ptr, "Directory not empty."); break;
		case Errno.ELOOP: strcpy(ret.ptr, "Too many symbolic links encountered."); break;
		case Errno.ENOMSG: strcpy(ret.ptr, "No message of desired type."); break;
		case Errno.EIDRM: strcpy(ret.ptr, "Identifier removed."); break;
		case Errno.ECHRNG: strcpy(ret.ptr, "Channel number out of range."); break;
		case Errno.EL2NSYNC: strcpy(ret.ptr, "Level 2 not synchronized."); break;
		case Errno.EL3HLT: strcpy(ret.ptr, "Level 3 halted."); break;
		case Errno.EL3RST: strcpy(ret.ptr, "Level 3 reset."); break;
		case Errno.ELNRNG: strcpy(ret.ptr, "Link number out of range."); break;
		case Errno.EUNATCH: strcpy(ret.ptr, "Protocol driver not attached."); break;
		case Errno.ENOCSI: strcpy(ret.ptr, "No CSI structure available."); break;
		case Errno.EL2HLT: strcpy(ret.ptr, "Level 2 halted."); break;
		case Errno.EBADE: strcpy(ret.ptr, "Invalid exchange."); break;
		case Errno.EBADR: strcpy(ret.ptr, "Invalid request descriptor."); break;
		case Errno.EXFULL: strcpy(ret.ptr, "Exchange full."); break;
		case Errno.ENOANO: strcpy(ret.ptr, "No anode."); break;
		case Errno.EBADRQC: strcpy(ret.ptr, "Invalid request code."); break;
		case Errno.EBADSLT: strcpy(ret.ptr, "Invalid slot."); break;
		case Errno.EBFONT: strcpy(ret.ptr, "Bad font file format."); break;
		case Errno.ENOSTR: strcpy(ret.ptr, "Device not a stream."); break;
		case Errno.ENODATA: strcpy(ret.ptr, "No data available."); break;
		case Errno.ETIME: strcpy(ret.ptr, "Timer expired."); break;
		case Errno.ENOSR: strcpy(ret.ptr, "Out of streams resources."); break;
		case Errno.ENONET: strcpy(ret.ptr, "Machine is not on the network."); break;
		case Errno.ENOPKG: strcpy(ret.ptr, "Package not installed."); break;
		case Errno.EREMOTE: strcpy(ret.ptr, "Object is remote."); break;
		case Errno.ENOLINK: strcpy(ret.ptr, "Link has been severed."); break;
		case Errno.EADV: strcpy(ret.ptr, "Advertise error."); break;
		case Errno.ESRMNT: strcpy(ret.ptr, "Srmount error."); break;
		case Errno.ECOMM: strcpy(ret.ptr, "Communication error on send."); break;
		case Errno.EPROTO: strcpy(ret.ptr, "Protocol error."); break;
		case Errno.EMULTIHOP: strcpy(ret.ptr, "Multihop attempted."); break;
		case Errno.EDOTDOT: strcpy(ret.ptr, "RFS specific error."); break;
		case Errno.EBADMSG: strcpy(ret.ptr, "Not a data message."); break;
		case Errno.EOVERFLOW: strcpy(ret.ptr, "Value too large for defined data type."); break;
		case Errno.ENOTUNIQ: strcpy(ret.ptr, "Name not unique on network."); break;
		case Errno.EBADFD: strcpy(ret.ptr, "File descriptor in bad state."); break;
		case Errno.EREMCHG: strcpy(ret.ptr, "Remote address changed."); break;
		case Errno.ELIBACC: strcpy(ret.ptr, "Can not access a needed shared library."); break;
		case Errno.ELIBBAD: strcpy(ret.ptr, "Accessing a corrupted shared library."); break;
		case Errno.ELIBSCN: strcpy(ret.ptr, ".lib section in a.out corrupted."); break;
		case Errno.ELIBMAX: strcpy(ret.ptr, "Attempting to link in too many shared libraries."); break;
		case Errno.ELIBEXEC: strcpy(ret.ptr, "Cannot exec a shared library directly."); break;
		case Errno.EILSEQ: strcpy(ret.ptr, "Illegal byte sequence."); break;
		case Errno.ERESTART: strcpy(ret.ptr, "Interrupted system call should be restarted."); break;
		case Errno.ESTRPIPE: strcpy(ret.ptr, "Streams pipe error."); break;
		case Errno.EUSERS: strcpy(ret.ptr, "Too many users."); break;
		case Errno.ENOTSOCK: strcpy(ret.ptr, "Socket operation on non-socket."); break;
		case Errno.EDESTADDRREQ: strcpy(ret.ptr, "Destination address required."); break;
		case Errno.EMSGSIZE: strcpy(ret.ptr, "Message too long."); break;
		case Errno.EPROTOTYPE: strcpy(ret.ptr, "Protocol wrong type for socket."); break;
		case Errno.ENOPROTOOPT: strcpy(ret.ptr, "Protocol not available."); break;
		case Errno.EPROTONOSUPPORT: strcpy(ret.ptr, "Protocol not supported."); break;
		case Errno.ESOCKTNOSUPPORT: strcpy(ret.ptr, "Socket type not supported."); break;
		case Errno.EOPNOTSUPP: strcpy(ret.ptr, "Operation not supported on transport endpoint."); break;
		case Errno.EPFNOSUPPORT: strcpy(ret.ptr, "Protocol family not supported."); break;
		case Errno.EAFNOSUPPORT: strcpy(ret.ptr, "Address family not supported by protocol."); break;
		case Errno.EADDRINUSE: strcpy(ret.ptr, "Address already in use."); break;
		case Errno.EADDRNOTAVAIL: strcpy(ret.ptr, "Cannot assign requested address."); break;
		case Errno.ENETDOWN: strcpy(ret.ptr, "Network is down."); break;
		case Errno.ENETUNREACH: strcpy(ret.ptr, "Network is unreachable."); break;
		case Errno.ENETRESET: strcpy(ret.ptr, "Network dropped connection because of reset."); break;
		case Errno.ECONNABORTED: strcpy(ret.ptr, "Software caused connection abort."); break;
		case Errno.ECONNRESET: strcpy(ret.ptr, "Connection reset by peer."); break;
		case Errno.ENOBUFS: strcpy(ret.ptr, "No buffer space available."); break;
		case Errno.EISCONN: strcpy(ret.ptr, "Transport endpoint is already connected."); break;
		case Errno.ENOTCONN: strcpy(ret.ptr, "Transport endpoint is not connected."); break;
		case Errno.ESHUTDOWN: strcpy(ret.ptr, "Cannot send after transport endpoint shutdown."); break;
		case Errno.ETOOMANYREFS: strcpy(ret.ptr, "Too many references: cannot splice."); break;
		case Errno.ETIMEDOUT: strcpy(ret.ptr, "Connection timed out."); break;
		case Errno.ECONNREFUSED: strcpy(ret.ptr, "Connection refused."); break;
		case Errno.EHOSTDOWN: strcpy(ret.ptr, "Host is down."); break;
		case Errno.EHOSTUNREACH: strcpy(ret.ptr, "No route to host."); break;
		case Errno.EALREADY: strcpy(ret.ptr, "Operation already in progress."); break;
		case Errno.EINPROGRESS: strcpy(ret.ptr, "Operation now in progress."); break;
		case Errno.ESTALE: strcpy(ret.ptr, "Stale file handle."); break;
		case Errno.EUCLEAN: strcpy(ret.ptr, "Structure needs cleaning."); break;
		case Errno.ENOTNAM: strcpy(ret.ptr, "Not a XENIX named type file."); break;
		case Errno.ENAVAIL: strcpy(ret.ptr, "No XENIX semaphores available."); break;
		case Errno.EISNAM: strcpy(ret.ptr, "Is a named type file."); break;
		case Errno.EREMOTEIO: strcpy(ret.ptr, "Remote I/O error."); break;
		case Errno.EDQUOT: strcpy(ret.ptr, "Quota exceeded."); break;
		case Errno.ENOMEDIUM: strcpy(ret.ptr, "No medium found."); break;
		case Errno.EMEDIUMTYPE: strcpy(ret.ptr, "Wrong medium type."); break;
		case Errno.ECANCELED: strcpy(ret.ptr, "Operation Canceled."); break;
		case Errno.ENOKEY: strcpy(ret.ptr, "Required key not available."); break;
		case Errno.EKEYEXPIRED: strcpy(ret.ptr, "Key has expired."); break;
		case Errno.EKEYREVOKED: strcpy(ret.ptr, "Key has been revoked."); break;
		case Errno.EKEYREJECTED: strcpy(ret.ptr, "Key was rejected by service."); break;
		case Errno.EOWNERDEAD: strcpy(ret.ptr, "Owner died."); break;
		case Errno.ENOTRECOVERABLE: strcpy(ret.ptr, "State not recoverable."); break;
		case Errno.ERFKILL: strcpy(ret.ptr, "Operation not possible due to RF-kill."); break;
		case Errno.EHWPOISON: strcpy(ret.ptr, "Memory page has hardware error."); break;
		default: errno = Errno.EINVAL; strcpy(ret.ptr, "Invalid error code."); break; // sprintf(ret.ptr, "Invalid error code %s.", num)
	}

	return ret.ptr;
}
